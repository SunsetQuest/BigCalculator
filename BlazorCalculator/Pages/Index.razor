@page "/"
@using System.Numerics;
@using System.Text.RegularExpressions
@using BigFloatLibrary;

<PageTitle>Big Number Calculator</PageTitle>

<MudPaper Class="pa-16 ma-2" Elevation="3">
    <!-- Input A -->
    <MudPaper Elevation="1" Class="d-flex align-center justify-center ma-4">
        <MudTextField Lines="5"
                      OnDebounceIntervalElapsed="CalculateAsync"
                      DebounceInterval="500"
                      Error="@inputAInvalidFormat"
                      @bind-Value="@inputAString"
                      HelperText="@($"RawMantissa:{inputA.RawMantissa} Size:{inputA.Size}  Scale:{inputA.Scale} BinExp:{inputA.BinaryExponent}")"
                      Label="Input A"
                      Variant="Variant.Outlined"
                      Adornment="Adornment.End"
                      AdornmentIcon="@inputATypeIcon"
                      OnAdornmentClick="InputABaseSelectClick"
                      AdornmentAriaLabel="Select Base">
        </MudTextField>
    </MudPaper>
    @if (NeedsB)
    {
        <!-- Input B -->
        <MudPaper Elevation="1" Class="d-flex align-center justify-center ma-4">
        <MudTextField Lines="5"
                      OnDebounceIntervalElapsed="CalculateAsync"
                      DebounceInterval="500"
                      Error="@inputBInvalidFormat"
                      @bind-Value="@inputBString"
                      HelperText="@($"Mantissa:{inputB.RoundedMantissa.ToBinaryString()} BinarySize:{inputB.Size} BinaryScale:{inputB.Scale} BinaryExp:{inputB.BinaryExponent}")"
                      Label="Input B"
                      Variant="Variant.Outlined"
                      Adornment="Adornment.End"
                      AdornmentIcon="@inputBTypeIcon"
                      OnAdornmentClick="InputBBaseSelectClick"
                      AdornmentAriaLabel="Select Base">
        </MudTextField>
    </MudPaper>
    }

    <!-- Operations Section - Fixed Layout -->
    <MudPaper Square="true" Class="d-flex align-center gap-4 pa-4">
        <!-- Toggle Group takes remaining space -->
        <div class="flex-grow-1">
            <MudToggleGroup T="Op" @bind-Value="op" 
            Color="Color.Primary" 
            SelectionMode="SelectionMode.SingleSelection">
                @foreach (var val in Enum.GetValues<Op>()[..5])
                {
                    <MudToggleItem Value="val">@(OpSymb[(int)val])</MudToggleItem>
                }
            </MudToggleGroup>
        </div>

        <!-- Select takes fixed 20% width -->
        <div class="flex-shrink-0" style="width: 20%; min-width: 130px;">
            <MudSelect T="Op"
                       @bind-Value="op"
                       Dense
                       Variant="Variant.Outlined"
                       Label="All Operations"
                       AnchorOrigin="Origin.BottomCenter">
                @foreach (var val in Enum.GetValues<Op>()[5..])
                {
                    <MudSelectItem Value="val">@val</MudSelectItem>
                }
            </MudSelect>
        </div>
    </MudPaper>

    <!-- Result -->
    <MudPaper Elevation="1" Class="d-flex align-center justify-center ma-4">
        <MudTextField Lines="5"
                      @bind-Value="@resultString"
                      HelperText="@($"RawMantissa:{inputB.RawMantissa} Size:{inputB.Size}  Scale:{inputB.Scale} Exp:{inputB.BinaryExponent}")"
                      Label="Result"
                      Variant="Variant.Filled"
                      Adornment="Adornment.End"
                      AdornmentIcon="@resultTypeIcon"
                      OnAdornmentClick="ResultBaseSelectClick"
                      AdornmentAriaLabel="Select Base"
                      ReadOnly>
        </MudTextField>
    </MudPaper>
</MudPaper>

<MudPaper Class="pa-16 ma-2" Elevation="3">
    <MudStack Reverse="true">
        @foreach(var resultHistory in resultHistories)
        {
            <MudPaper Class="pa-3">@resultHistory</MudPaper>
        }
    </MudStack>
</MudPaper>


@code {
    private bool _processing = false;

    Queue<string> resultHistories = new Queue<string>();

    Base inputAType = Base.Dec;
    Base inputBType = Base.Dec;
    Base resultType = Base.Dec;

    enum Base
    {
        Bin,
        Dec,
        Hex
    }

    private enum Op
    {
        Add, Sub, Mul, Div,
        Pow,          // A^B
        Root,         // B√A   (i.e. A^(1/B))
        Sqrt, Log2, 
        // Log10, Ln, Exp,
        Abs, Neg,
        ShiftLeft, ShiftRight
    }

    string[] OpSymb = [
        "+", "-", "X", "/", 
        "^", "n√", "√", "Log2", "|x|", "-", "<<", ">>"];

    private Op _op = Op.Add;

    private Op op
    {
        get { return _op; }
        set { 
                _op = value; 
                CalculateAsync("");
            }
    }
    

    // true = needs both inputs
    private bool NeedsB => _op is Op.Add or Op.Sub or Op.Mul or Op.Div or Op.Pow or Op.Root or Op.ShiftLeft or Op.ShiftRight;


    private string inputAString = "0";
    private bool inputAInvalidFormat = false;

    private string inputBString = "0";
    private bool inputBInvalidFormat = false;

    private string resultString = "0";

    BigFloat inputA = 0;
    BigFloat inputB = 0;
    BigFloat result = 0;

    async void SetOperation(Op operation)
    {
        _processing = true;
        _op = operation;
        await CalculateAsync("");
    }

    private async Task CalculateAsync(string debouncedText)
    {
        _processing = true;
        StateHasChanged();
        Calculate();        // or 'await Task.Delay(100).ContinueWith(t => Calculate());' ?
    }

    public async Task Execute(Action action, int timeoutInMilliseconds)
    {
        await Task.Delay(timeoutInMilliseconds);
        action();
    }

    private void Calculate()
    {
        if (inputAType == Base.Bin)
        {
            inputAInvalidFormat = !BigFloat.TryParseBinary(inputAString, out inputA);
        }
        else if (inputAType == Base.Dec)
        {
            inputAInvalidFormat = !BigFloat.TryParseDecimal(inputAString, out inputA);
        }
        else  // if (inputAType == Base.Hex)
        {
            inputAInvalidFormat = !BigFloat.TryParseHex(inputAString, out inputA);
        }

        if (inputBType == Base.Bin)
        {
            inputBInvalidFormat = !BigFloat.TryParseBinary(inputBString, out inputB);
        }
        else if (inputBType == Base.Dec)
        {
            inputBInvalidFormat = !BigFloat.TryParseDecimal(inputBString, out inputB);
        }
        else // if (inputBType == Base.Hex)
        {
            inputBInvalidFormat = !BigFloat.TryParseHex(inputBString, out inputB);
        }

        //Thread.SpinWait(2000000);
        
        if (inputAInvalidFormat || inputBInvalidFormat)
        {
            resultString = "";
            return;
        }

        result = _op switch
        {
            Op.Add => inputA + inputB,
            Op.Sub => inputA - inputB,
            Op.Mul => inputA * inputB,  //SmartMul(inputA, inputB),
            Op.Div => inputA / inputB,  //SmartDiv(inputA, inputB),
            Op.Pow => int.TryParse(inputBString, out int inputBAsInt) ? BigFloat.Pow(inputA, inputBAsInt) : 0,
            Op.Root => int.TryParse(inputBString, out int inputBAsInt) ? BigFloat.NthRoot(inputA, inputBAsInt) : 0,
            Op.Sqrt => BigFloat.Sqrt(inputA),
            Op.Log2 => (BigFloat)BigFloat.Log2(inputA),
            // Op.Ln => BigFloat.Log(inputA),
            // Op.Exp => BigFloat.Exp(inputA),
            Op.Abs => BigFloat.Abs(inputA),
            Op.Neg => -inputA,
            Op.ShiftRight => int.TryParse(inputBString, out int inputBAsInt) ? inputA >> inputBAsInt : 0,
            Op.ShiftLeft => int.TryParse(inputBString, out int inputBAsInt) ? inputA << inputBAsInt : 0,
            _ => 0
        };

        if (resultType == Base.Bin)
        {
            resultString = result.ToBinaryString();
        }
        else if (resultType == Base.Dec)
        {
            resultString = result.ToString();
        }
        else // if (resultType == Base.Hex)
        {
            resultString = result.ToHexString();
        }

        resultHistories.Enqueue(resultString);

        if (resultHistories.Count > 10)
        {
            resultHistories.Dequeue();
        }

        _processing = false;
        StateHasChanged();
    }
    
    // // --- helpers that respect “integer = exact” --------------------------
    // private static BigFloat SmartMul(BigFloat a, BigFloat b)
    //     => a.IsInteger ? b * (BigInteger)a : b.IsInteger ? a * (BigInteger)b : a * b;

    // private static BigFloat SmartDiv(BigFloat a, BigFloat b)
    //     => b.IsInteger ? a / (BigInteger)b : a / b;

    const string HexIcon = """"
<svg width="24" height="24" viewBox="0 0 24 24" >
  <circle cx="12" cy="12" r="11" fill="#fdf2f2" stroke="#e74c3c" stroke-width="1.5"/>
  <text x="12" y="9" font-family="monospace" font-size="8" font-weight="bold" fill="#c0392b" text-anchor="middle">0x</text>
  <text x="12" y="18" font-family="monospace" font-size="7" font-weight="bold" fill="#e74c3c" text-anchor="middle">FF</text>
</svg>
"""";

    const string BinIcon = """"
<svg width="24" height="24" viewBox="0 0 24 24" >
  <circle cx="12" cy="12" r="11" fill="#f0f8ff" stroke="#3498db" stroke-width="1.5"/>
  <text x="12" y="10" font-family="monospace" font-size="7" font-weight="bold" fill="#2980b9" text-anchor="middle">101</text>
  <text x="12" y="18" font-family="monospace" font-size="7" font-weight="bold" fill="#3498db" text-anchor="middle">011</text>
</svg>
"""";

    const string DecIcon = """"
<svg width="24" height="24" viewBox="0 0 24 24" >
  <circle cx="12" cy="12" r="11" fill="#f0fff4" stroke="#27ae60" stroke-width="1.5"/>
  <text x="12" y="16" font-family="monospace" font-size="10" font-weight="bold" fill="#229954" text-anchor="middle">123</text>
</svg>
"""";

    string inputATypeIcon = DecIcon;
    string inputBTypeIcon = DecIcon;
    string resultTypeIcon = DecIcon;

    void InputABaseSelectClick()
    {
        if (inputAType == Base.Bin)
        {
            inputATypeIcon = DecIcon;
            inputAType = Base.Dec;
        }
        else if (inputAType == Base.Dec)
        {
            inputATypeIcon = HexIcon;
            inputAType = Base.Hex;
        }
        else //if (inputAType == Base.Hex)
        {
            inputATypeIcon = BinIcon;
            inputAType = Base.Bin;
        }
    }

    void InputBBaseSelectClick()
    {
        if (inputBType == Base.Bin)
        {
            inputBTypeIcon = DecIcon;
            inputBType = Base.Dec;
        }
        else if (inputBType == Base.Dec)
        {
            inputBTypeIcon = HexIcon;
            inputBType = Base.Hex;
        }
        else //if (inputBType == Base.Hex)
        {
            inputBTypeIcon = BinIcon;
            inputBType = Base.Bin;
        }
    }

    void ResultBaseSelectClick()
    {
        if (resultType == Base.Bin)
        {
            resultTypeIcon = DecIcon;
            resultType = Base.Dec;
        }
        else if (resultType == Base.Dec)
        {
            resultTypeIcon = HexIcon;
            resultType = Base.Hex;
        }
        else //if (resultType == Base.Hex)
        {
            resultTypeIcon = BinIcon;
            resultType = Base.Bin;
        }
    }
}
