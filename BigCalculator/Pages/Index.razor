@page "/"
@using System.Numerics;
@using System.Text.RegularExpressions
@using BigFloatLibrary;
@using MudBlazor.Internal

@inject IJSRuntime JSRuntime
@inject ISnackbar Snackbar

<PageTitle>Big Number Calculator</PageTitle>

<!-- Error Display -->
@if (hasCalculationError)
{
    <MudAlert Severity="Severity.Error" Class="ma-2" ShowCloseIcon="true" CloseIconClicked="() => { hasCalculationError = false; errorMessage = string.Empty; }">
        @errorMessage
    </MudAlert>
}

<MudOverlay Visible="@_processing" DarkBackground="true">
    <MudPaper Elevation="6" Class="pa-6" Style="max-width: 360px;">
        <MudStack Spacing="2" AlignItems="AlignItems.Center">
            <MudText Typo="Typo.h6">Processing calculation</MudText>
            <MudText Typo="Typo.body2" Align="Align.Center">
                Running on your device. You can cancel if this takes too long.
            </MudText>
            <MudProgressCircular Color="Color.Primary" Size="Size.Medium" Indeterminate="true" />
            <MudText Typo="Typo.subtitle2">Time remaining: @_processingSecondsRemaining s</MudText>
            <MudButton Color="Color.Error" Variant="Variant.Filled" OnClick="CancelCalculation">
                Cancel
            </MudButton>
        </MudStack>
    </MudPaper>
</MudOverlay>

<MudPaper Class="pa-4 pa-sm-8 pa-md-16 ma-2" Elevation="3">
    <!-- Input A -->
    <MudPaper Elevation="1" Class="d-flex align-center justify-center ma-2 ma-md-4">
        <MudTextField Lines="3"
                      OnDebounceIntervalElapsed="CalculateAsync"
                      DebounceInterval="500"
                      Error="@inputAInvalidFormat"
                      ErrorText="@(inputAInvalidFormat ? $"Invalid {inputAType} format" : "")"
                      @bind-Value="@inputAString"
                      HelperText="@GetInputHelperText(inputA, inputAType)"
                      Label="Input A"
                      Variant="Variant.Outlined"
                      Adornment="Adornment.End"
                      AdornmentIcon="@inputATypeIcon"
                      OnAdornmentClick="InputABaseSelectClick"
                      AdornmentAriaLabel="Select Base"
                      Class="mud-input-large">
        </MudTextField>
    </MudPaper>

    @if (NeedsB)
    {
        <!-- Input B -->
        <MudPaper Elevation="1" Class="d-flex align-center justify-center ma-2 ma-md-4">
            <MudTextField Lines="3"
                          OnDebounceIntervalElapsed="CalculateAsync"
                          DebounceInterval="500"
                          Error="@inputBInvalidFormat"
                          ErrorText="@(inputBInvalidFormat ? $"Invalid {inputBType} format" : "")"
                          @bind-Value="@inputBString"
                          HelperText="@GetInputHelperText(inputB, inputBType)"
                          Label="Input B"
                          Variant="Variant.Outlined"
                          Adornment="Adornment.End"
                          AdornmentIcon="@inputBTypeIcon"
                          OnAdornmentClick="InputBBaseSelectClick"
                          AdornmentAriaLabel="Select Base"
                          Class="mud-input-large">
            </MudTextField>
        </MudPaper>
    }

    <!-- Operations Section - Improved Responsive Layout -->
    <MudPaper Elevation="1" Class="pa-3 ma-2 ma-md-4">
        <MudGrid Spacing="2" AlignItems="Center">
            <!-- Basic Operations Toggle Group -->
            <MudItem xs="12" sm="8" md="7" lg="8" Class="d-flex align-center">
                <MudToggleGroup T="Op" @bind-Value="op"
                                Color="Color.Primary"
                                SelectionMode="SelectionMode.SingleSelection"
                                Rounded="true"
                                Size="Size.Large"
                                Class="w-100">
                    @foreach (var val in Enum.GetValues<Op>()[..5])
                    {
                        <MudToggleItem Value="val" Text="@OpSymb[(int)val]" />
                    }
                </MudToggleGroup>
            </MudItem>

            <!-- Advanced Operations Select -->
            <MudItem xs="12" sm="4" md="2" lg="2" Class="d-flex align-center">
                <MudSelect T="Op"
                           @bind-Value="op"
                           Dense="false"
                           Variant="Variant.Outlined"
                           Label="More Operations"
                           AnchorOrigin="Origin.BottomCenter"
                           Class="w-100">
                    @foreach (var val in Enum.GetValues<Op>()[5..])
                    {
                        <MudSelectItem Value="val">@($"{OpSymb[(int)val]}")</MudSelectItem>
                    }
                </MudSelect>
            </MudItem>

            <!-- Precision Control -->
            <MudItem xs="12" sm="4" md="3" lg="2" Class="d-flex align-center">
                <MudSelect T="string"
                           @bind-Value="precisionMode"
                           @bind-Value:after="@(() => _ = CalculateAsync(""))"
                           Label="Precision"
                           Variant="Variant.Outlined"
                           Dense="true"
                           Onchange="() => _ = CalculateAsync(precisionMode)"
                           Class="w-100">
                           <!--HelperText="@GetPrecisionHelperText()"> -->
                    @foreach (var option in precisionOptions)
                    {
                        <MudSelectItem Value="option">
                            <MudTooltip Text="@GetPrecisionTooltip(option)" Placement="Placement.Left">
                                <span>
                                    @(char.IsLetter(option[0]) || option.Length > 4 ? option : $"{option} bits")
                                </span>
                            </MudTooltip>
                        </MudSelectItem>
                    }
                </MudSelect>
            </MudItem>
            
            <!-- Processing Indicator -->
            @if (_processing)
            {
                <MudItem xs="12" md="1" Class="d-flex justify-center align-center">
                    <MudProgressCircular Color="Color.Primary" Size="Size.Small" Indeterminate="true" />
                </MudItem>
            }
        </MudGrid>
    </MudPaper>

    <!-- Result -->
    <MudPaper Elevation="1" Class="ma-2 ma-md-4" Style="position: relative;">
        <MudGrid AlignItems="Center" Spacing="0">
            <MudItem xs="11">
                <MudTextField Lines="3"
                              @bind-Value="@resultString"
                              HelperText="@GetResultHelperText()"
                              Label="Result"
                              Variant="Variant.Filled"
                              ReadOnly="true"
                              Class="mud-input-large result-field">
                </MudTextField>
            </MudItem>
            <MudItem xs="1" Class="d-flex justify-center align-center" Style="height: 100%;">
                <MudStack Spacing="0" Style="gap: 1px;" AlignItems="AlignItems.Center">
                    <MudIconButton Icon="@Icons.Material.Filled.ContentCopy"
                                   OnClick="CopyResultToClipboard"
                                   Title="Copy to clipboard"
                                   Size="Size.Small"
                                   Style="width: 24px; height: 24px; min-height: 24px;" />
                    <MudButton Variant="Variant.Text"
                               OnClick="ResultBaseSelectClick"
                               Title="Change base format"
                               Size="Size.Small"
                               Style="width: 24px; height: 24px; min-height: 24px; padding: 2px;">
                        @((MarkupString)resultTypeIcon)
                    </MudButton>
                </MudStack>
            </MudItem>
        </MudGrid>
    </MudPaper>

    <!-- Quick Actions -->
    <MudPaper Class="pa-3 ma-2 ma-md-4" Elevation="1">
        <MudStack Row="true" Spacing="2" Wrap="Wrap.Wrap" Justify="Justify.Center" Class="d-flex flex-wrap">
            <MudButton OnClick="ClearAll" StartIcon="@Icons.Material.Filled.Clear" Color="Color.Warning" Size="Size.Small">
                Clear All
            </MudButton>
            <MudButton OnClick="SwapInputs" StartIcon="@Icons.Material.Filled.SwapVert" Color="Color.Info" Disabled="@(!NeedsB)" Size="Size.Small">
                Swap A ↔ B
            </MudButton>
            <MudButton OnClick="CopyResultToA" StartIcon="@Icons.Material.Filled.Input" Color="Color.Primary" Disabled="@(string.IsNullOrEmpty(resultString) || resultString == "Error")" Size="Size.Small">
                Result → A
            </MudButton>
        </MudStack>
    </MudPaper>
</MudPaper>

<!-- Enhanced History Section with Better Responsive Layout -->
<MudPaper Class="pa-4 pa-sm-8 pa-md-16 ma-2" Elevation="3">
    <MudText Typo="Typo.h6" Class="mb-4">Calculation History</MudText>
    <MudStack Reverse="true" Spacing="2">
        @foreach (var (result, index) in resultHistories.Select((r, i) => (r, i)))
        {
            <MudPaper Class="pa-3" Elevation="1">
                <MudGrid AlignItems="Center" Spacing="2">
                    <MudItem xs="12" sm="8" md="9">
                        <MudText Class="font-monospace text-truncate" Style="overflow-wrap: break-word; word-break: break-all; font-size: 0.875rem;">
                            @result
                        </MudText>
                    </MudItem>
                    <MudItem xs="12" sm="4" md="3">
                        <MudStack Row="true" Spacing="1" Justify="Justify.FlexEnd" Class="flex-wrap">
                            <MudButton StartIcon="@Icons.Material.Filled.Input"
                                       Color="Color.Primary"
                                       Size="Size.Small"
                                       Variant="Variant.Outlined"
                                       OnClick="() => TransferToInputA(result)">
                                → A
                            </MudButton>
                            <MudButton StartIcon="@Icons.Material.Filled.Input"
                                       Color="Color.Secondary"
                                       Size="Size.Small"
                                       Variant="Variant.Outlined"
                                       OnClick="() => TransferToInputB(result)"
                                       Disabled="@(!NeedsB)">
                                → B
                            </MudButton>
                            <MudButton StartIcon="@Icons.Material.Filled.Delete"
                                       Color="Color.Error"
                                       Size="Size.Small"
                                       Variant="Variant.Outlined"
                                       OnClick="() => RemoveFromHistory(index)">
                                ×
                            </MudButton>
                        </MudStack>
                    </MudItem>
                </MudGrid>
            </MudPaper>
        }
        @if (!resultHistories.Any())
        {
            <MudAlert Severity="Severity.Info" Class="ma-2">
                <MudText>No calculations performed yet. Results will appear here.</MudText>
            </MudAlert>
        }
    </MudStack>
</MudPaper>

@code {
    // Convert Queue to List for better manipulation
    List<string> resultHistories = new List<string>();

    // Precision Control Variables
    private string precisionMode = "Auto";
    private readonly List<string> precisionOptions = new List<string>
    {
        "Auto",
        "Full",
        "16",
        "32",
        "64",
        "128",
        "256",
        "512",
        "1024",
        "2048",
        "4096",
        "8192",
        "16K",
        "32K",
        "64K",
        "128K",
        "256K",
        "512K",
        "1M"
    };


    // UI Action Methods

    private void TransferToInputA(string value)
    {
        // Lets transfer anything after the "=" in value to inputAString
        inputAString = value.Split('=').Last().Trim();

        _ = CalculateAsync("");
        StateHasChanged();
    }

    private void TransferToInputB(string value)
    {
        //if (NeedsB)
        {
            // Lets transfer anything after the "=" in value to inputAString
            inputBString = value.Split('=').Last().Trim();
            _ = CalculateAsync("");
            StateHasChanged();
        }
    }

    private void RemoveFromHistory(int index)
    {
        if (index >= 0 && index < resultHistories.Count)
        {
            resultHistories.RemoveAt(index);
            StateHasChanged();
        }
    }
}


<style>
    .mud-input-large .mud-input-control {
        font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
        font-size: 1.1em;
    }

    .result-field .mud-input-control {
        background-color: var(--mud-palette-background-grey);
        font-weight: 500;
    }

    .history-item:hover {
        background-color: var(--mud-palette-action-hover);
        transition: background-color 0.2s ease;
    }

    .mud-toggle-group .mud-toggle-item {
        min-width: 60px;
        font-weight: 600;
    }

    /* Mobile styles - using class-based approach instead of media queries */
    .mobile-small-text .mud-input-large .mud-input-control {
        font-size: 0.95em;
    }

    .mobile-small-text .font-monospace {
        font-size: 0.8rem !important;
    }

    .mobile-wrap .mud-toggle-group {
        flex-wrap: wrap;
    }

        .mobile-wrap .mud-toggle-group .mud-toggle-item {
            min-width: 50px;
            margin: 2px;
        }
</style>

@code {
    private bool _processing = false;
    private const int CalculationTimeoutSeconds = 5;
    private int _processingSecondsRemaining = CalculationTimeoutSeconds;
    private CancellationTokenSource? _calculationCts;
    private int _calculationSequence = 0;
    private string errorMessage = "";
    private bool hasCalculationError = false;


    Base inputAType = Base.Dec;
    Base inputBType = Base.Dec;
    Base resultType = Base.Dec;

    enum Base
    {
        Bin,
        Dec,
        Hex
    }

    private enum Op
    {
        Add, Sub, Mul, Div,
        Pow,          // A^B
        Root,         // B√A   (i.e. A^(1/B))
        Sqrt, Log2, Log10, Ln, Exp,
        Abs, Neg,
        ShiftLeft, ShiftRight,
        Sin, Cos, Tan
    }

    string[] OpSymb = [
        "+", "-", "×", "÷",
        "^", "∜", "√", "log₂", "log₁₀", "ln", "eˣ",
        "|x|", "±", "<<", ">>",
        "sin", "cos", "tan"];

    private Op _op = Op.Add;

    private Op op
    {
        get { return _op; }
        set
        {
            _op = value;
            _ = CalculateAsync("");
        }
    }

    private bool NeedsB => _op is Op.Add or Op.Sub or Op.Mul or Op.Div or Op.Pow or Op.Root or Op.ShiftLeft or Op.ShiftRight;

    private string inputAString = "0";
    private bool inputAInvalidFormat = false;

    private string inputBString = "0";
    private bool inputBInvalidFormat = false;

    private string resultString = "0";

    BigFloat inputA = 0;
    BigFloat inputB = 0;
    BigFloat result = 0;

    private async Task CalculateAsync(string debouncedText)
    {
        if (_processing)
        {
            CancelCalculation();
            return;
        }

        _processing = true;
        _processingSecondsRemaining = CalculationTimeoutSeconds;
        var calculationId = ++_calculationSequence;
        _calculationCts?.Cancel();
        _calculationCts?.Dispose();
        _calculationCts = new CancellationTokenSource();

        var snapshot = new CalculationSnapshot(
            inputAString,
            inputBString,
            inputAType,
            inputBType,
            resultType,
            _op,
            precisionMode);

        await InvokeAsync(StateHasChanged);
        await Task.Yield();

        await Task.Delay(50);

        using var countdownCts = new CancellationTokenSource();
        var countdownTask = RunCountdownAsync(countdownCts.Token);
        var calculationTask = Task.Factory.StartNew(
            () => CalculateCore(snapshot, _calculationCts.Token),
            _calculationCts.Token,
            TaskCreationOptions.LongRunning,
            TaskScheduler.Default);
        _ = calculationTask.ContinueWith(task => _ = task.Exception, TaskContinuationOptions.OnlyOnFaulted);

        try
        {
            var timeoutTask = Task.Delay(TimeSpan.FromSeconds(CalculationTimeoutSeconds), _calculationCts.Token);
            var completedTask = await Task.WhenAny(calculationTask, timeoutTask);

            if (completedTask == calculationTask)
            {
                try
                {
                    var calculationResult = await calculationTask;
                    if (_calculationSequence == calculationId && !_calculationCts.IsCancellationRequested)
                    {
                        ApplyCalculationResult(calculationResult);
                    }
                }
                catch (OperationCanceledException)
                {
                    SetCancellationMessage(_calculationCts.IsCancellationRequested);
                }
            }
            else
            {
                var userCanceled = _calculationCts.IsCancellationRequested;
                if (!userCanceled)
                {
                    _calculationCts.Cancel();
                }
                SetCancellationMessage(userCanceled);
            }
        }
        finally
        {
            countdownCts.Cancel();
            _processing = false;
            _processingSecondsRemaining = 0;
            await InvokeAsync(StateHasChanged);
        }
    }

    private void CancelCalculation()
    {
        if (!_processing)
            return;

        _calculationCts?.Cancel();
        _processingSecondsRemaining = 0;
        StateHasChanged();
    }

    private async Task RunCountdownAsync(CancellationToken token)
    {
        while (_processingSecondsRemaining > 0 && !token.IsCancellationRequested)
        {
            try
            {
                await Task.Delay(1000, token);
            }
            catch (TaskCanceledException)
            {
                break;
            }

            _processingSecondsRemaining = Math.Max(0, _processingSecondsRemaining - 1);
            await InvokeAsync(StateHasChanged);
        }
    }

    private void SetCancellationMessage(bool userCanceled)
    {
        hasCalculationError = true;
        errorMessage = userCanceled
            ? "Calculation canceled by user."
            : $"Calculation timed out after {CalculationTimeoutSeconds} seconds.";
        resultString = "Canceled";
    }

    private CalculationResult CalculateCore(CalculationSnapshot snapshot, CancellationToken token)
    {
        var calculation = new CalculationResult();

        try
        {
            BigFloat inputAValue = 0;
            BigFloat inputBValue = 0;

            token.ThrowIfCancellationRequested();

            bool inputAValid = snapshot.InputAType switch
            {
                Base.Bin => BigFloat.TryParseBinary(snapshot.InputAString?.Trim() ?? "", out inputAValue),
                Base.Dec => BigFloat.TryParseDecimal(snapshot.InputAString?.Trim() ?? "", out inputAValue),
                Base.Hex => BigFloat.TryParseHex(snapshot.InputAString?.Trim() ?? "", out inputAValue),
                _ => false
            };

            token.ThrowIfCancellationRequested();

            bool needsB = NeedsBForOperation(snapshot.Operation);
            bool inputBValid = true;

            if (needsB)
            {
                inputBValid = snapshot.InputBType switch
                {
                    Base.Bin => BigFloat.TryParseBinary(snapshot.InputBString?.Trim() ?? "", out inputBValue),
                    Base.Dec => BigFloat.TryParseDecimal(snapshot.InputBString?.Trim() ?? "", out inputBValue),
                    Base.Hex => BigFloat.TryParseHex(snapshot.InputBString?.Trim() ?? "", out inputBValue),
                    _ => false
                };
            }

            calculation.InputAInvalidFormat = !inputAValid;
            calculation.InputBInvalidFormat = needsB && !inputBValid;
            calculation.InputA = inputAValue;
            calculation.InputB = inputBValue;

            if (!inputAValid || (needsB && !inputBValid))
            {
                calculation.ResultString = "";
                return calculation;
            }

            ApplyPrecisionControl(ref inputAValue, ref inputBValue, snapshot.PrecisionMode, snapshot.Operation, needsB);

            token.ThrowIfCancellationRequested();

            var resultValue = snapshot.Operation switch
            {
                Op.Add => inputAValue + inputBValue,
                Op.Sub => inputAValue - inputBValue,
                Op.Mul => inputAValue * inputBValue,
                Op.Div => ValidateDivision(inputAValue, inputBValue),
                Op.Pow => ValidatePower(inputAValue, snapshot.InputBString),
                Op.Root => ValidateRoot(inputAValue, snapshot.InputBString),
                Op.Sqrt => ValidateSquareRoot(inputAValue),
                Op.Log2 => ValidateLogarithm(inputAValue),
                Op.Abs => BigFloat.Abs(inputAValue),
                Op.Neg => -inputAValue,
                Op.ShiftRight => ValidateShift(inputAValue, snapshot.InputBString, false),
                Op.ShiftLeft => ValidateShift(inputAValue, snapshot.InputBString, true),
                _ => throw new NotImplementedException($"Operation {snapshot.Operation} not implemented")
            };

            calculation.InputA = inputAValue;
            calculation.InputB = inputBValue;
            calculation.ResultValue = resultValue;

            calculation.ResultString = snapshot.ResultType switch
            {
                Base.Bin => resultValue.ToBinaryString(),
                Base.Dec => resultValue.ToString(),
                Base.Hex => resultValue.ToHexString(),
                _ => resultValue.ToString()
            };

            calculation.HistoryEntry = FormatHistoryEntry(
                snapshot.InputAString,
                snapshot.InputBString,
                calculation.ResultString,
                snapshot.Operation,
                snapshot.InputAType,
                snapshot.InputBType,
                snapshot.ResultType);
        }
        catch (OperationCanceledException)
        {
            calculation.HasError = true;
            calculation.ErrorMessage = "Calculation canceled.";
            calculation.ResultString = "Canceled";
        }
        catch (Exception ex)
        {
            calculation.HasError = true;
            calculation.ErrorMessage = $"Calculation error: {ex.Message}";
            calculation.ResultString = "Error";
        }

        return calculation;
    }

    private void ApplyCalculationResult(CalculationResult calculation)
    {
        hasCalculationError = calculation.HasError;
        errorMessage = calculation.ErrorMessage ?? "";
        inputAInvalidFormat = calculation.InputAInvalidFormat;
        inputBInvalidFormat = calculation.InputBInvalidFormat;
        inputA = calculation.InputA;
        inputB = calculation.InputB;
        result = calculation.ResultValue;
        resultString = calculation.ResultString;

        if (!calculation.HasError && !string.IsNullOrWhiteSpace(calculation.HistoryEntry))
        {
            resultHistories.Insert(0, calculation.HistoryEntry);

            if (resultHistories.Count > 20)
            {
                resultHistories.RemoveAt(resultHistories.Count - 1);
            }
        }
    }

    private static bool NeedsBForOperation(Op operation)
        => operation is Op.Add or Op.Sub or Op.Mul or Op.Div or Op.Pow or Op.Root or Op.ShiftLeft or Op.ShiftRight;

    private void ApplyPrecisionControl(ref BigFloat inputAValue, ref BigFloat inputBValue, string mode, Op operation, bool needsB)
    {
        // Parse precision mode to get the numeric value if it's a fixed precision
        int? fixedPrecision = GetFixedPrecisionValue(mode);

        if (fixedPrecision.HasValue)
        {
            // Fixed precision mode
            int precisionBits = fixedPrecision.Value;

            // Apply precision based on operation type
            if (operation is Op.Add or Op.Sub)
            {
                // For Add/Sub operations, we work with accuracy
                if (inputAValue.Accuracy < precisionBits)
                    inputAValue = BigFloat.ExtendPrecision(inputAValue, precisionBits - inputAValue.Accuracy);
                if (needsB && inputBValue.Accuracy < precisionBits)
                    inputBValue = BigFloat.ExtendPrecision(inputBValue, precisionBits - inputBValue.Accuracy);
            }
            else
            {
                // For Mul/Div/Pow operations, we work with precision
                if (inputAValue.Precision < precisionBits)
                    inputAValue = BigFloat.SetPrecision(inputAValue, precisionBits);
                if (needsB && inputBValue.Precision < precisionBits)
                    inputBValue = BigFloat.SetPrecision(inputBValue, precisionBits);
            }
        }
        else if (mode == "Auto")
        {
            // Auto mode with special integer handling
            bool aIsInteger = inputAValue.IsInteger;
            bool bIsInteger = needsB ? inputBValue.IsInteger : false;

            if (needsB && aIsInteger && bIsInteger)
            {
                // Both are integers - keep as exact integers
                // BigFloat should handle this naturally
            }
            else if (needsB && (aIsInteger || bIsInteger))
            {
                // One is integer, one is not - match precision of non-integer
                if (aIsInteger && !bIsInteger)
                {
                    // A is integer, B is not - match A's precision to B's
                    inputAValue = BigFloat.SetPrecision(inputAValue, inputBValue.Precision);
                }
                else if (!aIsInteger && bIsInteger)
                {
                    // B is integer, A is not - match B's precision to A's
                    inputBValue = BigFloat.SetPrecision(inputBValue, inputAValue.Precision);
                }
            }
            // Otherwise let BigFloat use its default precision handling
        }
        else if (mode == "Full")
        {
            // Match the longer input's precision
            if (needsB)
            {
                int maxPrecision = Math.Max(inputAValue.Precision, inputBValue.Precision);

                if (inputAValue.Precision < maxPrecision)
                    inputAValue = BigFloat.SetPrecision(inputAValue, maxPrecision);
                if (inputBValue.Precision < maxPrecision)
                    inputBValue = BigFloat.SetPrecision(inputBValue, maxPrecision);
            }
            // For single-input operations, keep the existing precision
        }
    }

    private int? GetFixedPrecisionValue(string mode)
    {
        if (mode == "Auto" || mode == "Full")
            return null;
        if (mode.EndsWith("K"))
        {
            // Handle kilobit values
            if (int.TryParse(mode.TrimEnd('K'), out int kilobits))
                return kilobits * 1024;
        }
        else if (mode.EndsWith("M"))
        {
            // Handle megabit values
            if (int.TryParse(mode.TrimEnd('M'), out int megabits))
                return megabits * 1024 * 1024;
        }
        else if (int.TryParse(mode, out int bits))
        {
            return bits;
        }

        return null;
    }

    private BigFloat ValidateDivision(BigFloat a, BigFloat b)
    {
        if (b == 0)
        {
            throw new DivideByZeroException("Division by zero is undefined");
        }
        return a / b;
    }

    private BigFloat ValidatePower(BigFloat a, string bString)
    {
        if (!int.TryParse(bString, out int exponent))
        {
            throw new ArgumentException("Power operation requires integer exponent");
        }
        if (a == 0 && exponent < 0)
        {
            throw new ArgumentException("Cannot raise zero to negative power");
        }
        return BigFloat.Pow(a, exponent);
    }

    private BigFloat ValidateRoot(BigFloat a, string bString)
    {
        if (!int.TryParse(bString, out int root))
        {
            throw new ArgumentException("Root operation requires integer root value");
        }
        if (root == 0)
        {
            throw new ArgumentException("Root cannot be zero");
        }
        if (a < 0 && root % 2 == 0)
        {
            throw new ArgumentException("Even root of negative number is not real");
        }
        return BigFloat.NthRoot(a, root);
    }

    private BigFloat ValidateSquareRoot(BigFloat a)
    {
        if (a < 0)
        {
            throw new ArgumentException("Square root of negative number is not real");
        }
        return BigFloat.Sqrt(a);
    }

    private BigFloat ValidateLogarithm(BigFloat a)
    {
        if (a <= 0)
        {
            throw new ArgumentException("Logarithm undefined for non-positive numbers");
        }
        return (BigFloat)BigFloat.Log2(a);
    }

    private BigFloat ValidateShift(BigFloat a, string bString, bool leftShift)
    {
        if (!int.TryParse(bString, out int shiftAmount))
        {
            throw new ArgumentException("Shift operation requires integer shift amount");
        }
        if (Math.Abs(shiftAmount) > 1000000) // Reasonable limit
        {
            throw new ArgumentException("Shift amount too large");
        }
        return leftShift ? a << shiftAmount : a >> shiftAmount;
    }

    private string FormatHistoryEntry(string inputAValue, string inputBValue, string resultValue, Op operation, Base inputATypeValue, Base inputBTypeValue, Base resultTypeValue)
    {
        var aStr = FormatValueForHistory(inputAValue, inputATypeValue);
        var resultStr = FormatValueForHistory(resultValue, resultTypeValue);

        if (NeedsBForOperation(operation))
        {
            var bStr = FormatValueForHistory(inputBValue, inputBTypeValue);
            return $"{aStr} {OpSymb[(int)operation]} {bStr} = {resultStr}";
        }
        else
        {
            return $"{OpSymb[(int)operation]}({aStr}) = {resultStr}";
        }
    }

    private string FormatValueForHistory(string value, Base baseType)
    {
        var prefix = baseType switch
        {
            Base.Bin => "0b",
            Base.Hex => "0x",
            _ => ""
        };
        return $"{prefix}{value}";
    }

    // Helper methods
    private string GetInputHelperText(BigFloat value, Base baseType)
    {
        if (value == 0) return $"{baseType} format";
        return $"Bits: {value.Size} | Precision: {value.Precision} | Accuracy: {value.Accuracy} | Scale: {value.Scale} | BinExp: {value.BinaryExponent}{(value.IsInteger ? "| IsInteger" : "")}{(value.FitsInADouble ? "| FitsInADouble" : "")}{(value.IsOneBitFollowedByZeroBits ? "| IsOneBitFollowedByZeroBits" : "")}";
    }

    private string GetResultHelperText()
    {
        if (result == 0 || hasCalculationError) return $"{resultType} format";

        string baseInfo = $"Bits: {result.Size} | Precision: {result.Precision} | Accuracy: {result.Accuracy} | Scale: {result.Scale} | BinExp: {result.BinaryExponent}";
        string flags = $"{(result.IsInteger ? "| IsInteger" : "")}{(result.FitsInADouble ? "| FitsInADouble" : "")}{(result.IsOneBitFollowedByZeroBits ? "| IsOneBitFollowedByZeroBits" : "")}";
        string modeInfo = $" | Mode: {precisionMode}";

        return baseInfo + flags + modeInfo;
    }

    private string GetPrecisionHelperText()
    {
        return precisionMode switch
        {
            "Auto" => "Automatic precision with smart integer handling",
            "Full" => "Match precision of the longer input",
            _ => "Fixed precision mode"
        };
    }

    private string GetPrecisionTooltip(string option)
    {
        return option switch
        {
            "Auto" => "Automatic precision. Integers are treated as exact when mixed with decimals.",
            "Full" => "Result precision matches the input with higher precision.",
            _ when option.EndsWith("K") => $"Fixed {option} ({int.Parse(option.TrimEnd('K')) * 1024:N0} bits)",
            _ when option.EndsWith("M") => $"Fixed {option} ({int.Parse(option.TrimEnd('M')) * 1024 * 1024:N0} bits)",
            _ => $"Fixed {option}-bit precision"
        };
    }

    private string ExtractResultValue(string historyEntry)
    {
        var equalIndex = historyEntry.LastIndexOf(" = ");
        if (equalIndex == -1) return "";

        var resultPart = historyEntry.Substring(equalIndex + 3);
        // Remove precision info [...]
        var bracketIndex = resultPart.LastIndexOf(" [");
        if (bracketIndex != -1)
            resultPart = resultPart.Substring(0, bracketIndex);

        // Remove base prefixes
        if (resultPart.StartsWith("0b")) return resultPart.Substring(2);
        if (resultPart.StartsWith("0x")) return resultPart.Substring(2);
        return resultPart;
    }


    private void ClearHistory()
    {
        resultHistories.Clear();
        StateHasChanged();
    }

    private sealed class CalculationSnapshot
    {
        public CalculationSnapshot(string inputAString, string inputBString, Base inputAType, Base inputBType, Base resultType, Op operation, string precisionMode)
        {
            InputAString = inputAString;
            InputBString = inputBString;
            InputAType = inputAType;
            InputBType = inputBType;
            ResultType = resultType;
            Operation = operation;
            PrecisionMode = precisionMode;
        }

        public string InputAString { get; }
        public string InputBString { get; }
        public Base InputAType { get; }
        public Base InputBType { get; }
        public Base ResultType { get; }
        public Op Operation { get; }
        public string PrecisionMode { get; }
    }

    private sealed class CalculationResult
    {
        public bool HasError { get; set; }
        public string ErrorMessage { get; set; } = "";
        public bool InputAInvalidFormat { get; set; }
        public bool InputBInvalidFormat { get; set; }
        public BigFloat InputA { get; set; }
        public BigFloat InputB { get; set; }
        public BigFloat ResultValue { get; set; }
        public string ResultString { get; set; } = "";
        public string? HistoryEntry { get; set; }
    }

    private void ClearAll()
    {
        inputAString = "0";
        inputBString = "0";
        resultString = "0";
        inputA = inputB = result = 0;
        inputAInvalidFormat = inputBInvalidFormat = false;
        hasCalculationError = false;
        errorMessage = "";
        StateHasChanged();
    }

    private void SwapInputs()
    {
        if (NeedsB)
        {
            (inputAString, inputBString) = (inputBString, inputAString);
            (inputAType, inputBType) = (inputBType, inputAType);
            (inputATypeIcon, inputBTypeIcon) = (inputBTypeIcon, inputATypeIcon);
            _ = CalculateAsync("");
        }
    }

    private void CopyResultToA()
    {
        if (!string.IsNullOrEmpty(resultString) && resultString != "Error")
        {
            inputAString = ExtractResultValue($"dummy = {resultString}");
            inputAType = resultType;
            inputATypeIcon = resultTypeIcon;
            _ = CalculateAsync("");
        }
    }



    // Replace the existing CopyResultToClipboard method
    private async Task CopyResultToClipboard()
    {
        if (string.IsNullOrEmpty(resultString) || resultString == "Error")
        {
            Snackbar.Add("No valid result to copy", Severity.Warning);
            return;
        }

        try
        {
            // Modern clipboard API (preferred)
            await JSRuntime.InvokeVoidAsync("navigator.clipboard.writeText", resultString);
            Snackbar.Add("Result copied to clipboard!", Severity.Success);
        }
        catch (JSException)
        {
            try
            {
                // Fallback for older browsers
                await JSRuntime.InvokeVoidAsync("fallbackCopyToClipboard", resultString);
                Snackbar.Add("Result copied to clipboard!", Severity.Success);
            }
            catch (Exception ex)
            {
                Snackbar.Add($"Failed to copy: {ex.Message}", Severity.Error);
            }
        }

        // StateHasChanged() not needed here since we're not modifying component state
        // The snackbar notifications handle user feedback
    }

    // Base conversion icons and handlers
    const string HexIcon = """"
        <svg width="24" height="24" viewBox="0 0 24 24">
          <circle cx="12" cy="12" r="11" fill="#fdf2f2" stroke="#e74c3c" stroke-width="1.5"/>
          <text x="12" y="9" font-family="monospace" font-size="8" font-weight="bold" fill="#c0392b" text-anchor="middle">0x</text>
          <text x="12" y="18" font-family="monospace" font-size="7" font-weight="bold" fill="#e74c3c" text-anchor="middle">FF</text>
        </svg>
        """";

    const string BinIcon = """"
        <svg width="24" height="24" viewBox="0 0 24 24">
          <circle cx="12" cy="12" r="11" fill="#f0f8ff" stroke="#3498db" stroke-width="1.5"/>
          <text x="12" y="10" font-family="monospace" font-size="7" font-weight="bold" fill="#2980b9" text-anchor="middle">101</text>
          <text x="12" y="18" font-family="monospace" font-size="7" font-weight="bold" fill="#3498db" text-anchor="middle">011</text>
        </svg>
        """";

    const string DecIcon = """"
        <svg width="24" height="24" viewBox="0 0 24 24">
          <circle cx="12" cy="12" r="11" fill="#f0fff4" stroke="#27ae60" stroke-width="1.5"/>
          <text x="12" y="16" font-family="monospace" font-size="10" font-weight="bold" fill="#229954" text-anchor="middle">123</text>
        </svg>
        """";

    string inputATypeIcon = DecIcon;
    string inputBTypeIcon = DecIcon;
    string resultTypeIcon = DecIcon;

    void InputABaseSelectClick()
    {
        BigFloat parsedValue = default;

        // Try to parse current value with current base
        bool canParse = inputAType switch
        {
            Base.Bin => BigFloat.TryParseBinary(inputAString?.Trim() ?? "", out parsedValue),
            Base.Dec => BigFloat.TryParseDecimal(inputAString?.Trim() ?? "", out parsedValue),
            Base.Hex => BigFloat.TryParseHex(inputAString?.Trim() ?? "", out parsedValue),
            _ => false
        };

        // Change to next base
        inputAType = inputAType switch
        {
            Base.Dec => Base.Hex,
            Base.Hex => Base.Bin,
            Base.Bin => Base.Dec,
            _ => Base.Dec
        };

        if (canParse)
        {
            // Convert to new base representation
            inputAString = inputAType switch
            {
                Base.Bin => parsedValue.ToBinaryString(),
                Base.Dec => parsedValue.ToString(),
                Base.Hex => parsedValue.ToHexString(),
                _ => parsedValue.ToString()
            };
        }
        else if (!string.IsNullOrWhiteSpace(inputAString) && inputAString != "0")
        {
            // If can't parse and there's content, clear invalid input
            inputAString = "0";
        }
        // If can't parse, leave inputAString unchanged but still change the base type

        // Update icon
        inputATypeIcon = inputAType switch
        {
            Base.Dec => DecIcon,
            Base.Hex => HexIcon,
            Base.Bin => BinIcon,
            _ => DecIcon
        };

        _ = CalculateAsync("");
    }

    void InputBBaseSelectClick()
    {
        BigFloat parsedValue = default;

        // Try to parse current value with current base
        bool canParse = inputBType switch
        {
            Base.Bin => BigFloat.TryParseBinary(inputBString?.Trim() ?? "", out parsedValue),
            Base.Dec => BigFloat.TryParseDecimal(inputBString?.Trim() ?? "", out parsedValue),
            Base.Hex => BigFloat.TryParseHex(inputBString?.Trim() ?? "", out parsedValue),
            _ => false
        };

        // Change to next base
        inputBType = inputBType switch
        {
            Base.Dec => Base.Hex,
            Base.Hex => Base.Bin,
            Base.Bin => Base.Dec,
            _ => Base.Dec
        };

        if (canParse)
        {
            // Convert to new base representation
            inputBString = inputBType switch
            {
                Base.Bin => parsedValue.ToBinaryString(),
                Base.Dec => parsedValue.ToString(),
                Base.Hex => parsedValue.ToHexString(),
                _ => parsedValue.ToString()
            };
        }
        else if (!string.IsNullOrWhiteSpace(inputBString) && inputBString != "0")
        {
            // If can't parse and there's content, clear invalid input
            inputBString = "0";
        }
        // If can't parse, leave inputBString unchanged but still change the base type

        // Update icon
        inputBTypeIcon = inputBType switch
        {
            Base.Dec => DecIcon,
            Base.Hex => HexIcon,
            Base.Bin => BinIcon,
            _ => DecIcon
        };

        _ = CalculateAsync("");
    }

    void ResultBaseSelectClick()
    {
        // For results, we can directly use the stored result value for conversion
        // Change to next base
        resultType = resultType switch
        {
            Base.Dec => Base.Hex,
            Base.Hex => Base.Bin,
            Base.Bin => Base.Dec,
            _ => Base.Dec
        };

        // Convert result to new base representation if we have a valid result
        if (result != 0 || resultString == "0")
        {
            resultString = resultType switch
            {
                Base.Bin => result.ToBinaryString(),
                Base.Dec => result.ToString(),
                Base.Hex => result.ToHexString(),
                _ => result.ToString()
            };
        }

        // Update icon
        resultTypeIcon = resultType switch
        {
            Base.Dec => DecIcon,
            Base.Hex => HexIcon,
            Base.Bin => BinIcon,
            _ => DecIcon
        };

        // No need to recalculate for result conversion, just update the display
        StateHasChanged();
    }
}
